

<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>React核心概念 - pingchangxin&#39;Blog</title>
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="google" content="notranslate" />

  
  
  <meta name="description" content="一、最简易的React示例1234ReactDom.r..."> 
  
  <meta name="author" content="pingchangxin"> 

  
    <link rel="icon" href="/images/icons/favicon-16x16.png" type="image/png" sizes="16x16">
  
  
    <link rel="icon" href="/images/icons/favicon-32x32.png" type="image/png" sizes="32x32">
  
  
    <link rel="apple-touch-icon" href="/images/icons/apple-touch-icon.png" sizes="180x180">
  
  
    <meta rel="mask-icon" href="/images/icons/stun-logo.svg" color="#333333">
  
  
    <meta rel="msapplication-TileImage" content="/images/icons/favicon-144x144.png">
    <meta rel="msapplication-TileColor" content="#000000">
  

  
<link rel="stylesheet" href="/css/style.css">


  
  
<link rel="stylesheet" href="//at.alicdn.com/t/font_1445822_hhodbqn7tit.css">

  

  
  
  
<link rel="stylesheet" href="https://cdn.bootcss.com/fancybox/3.5.7/jquery.fancybox.min.css">

  

  
  
  
<link rel="stylesheet" href="https://cdn.bootcss.com/highlight.js/9.18.1/styles/xcode.min.css">

  

  
  
  
<link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/justifiedGallery/3.7.0/css/justifiedGallery.min.css">

  

  <script>
    var CONFIG = window.CONFIG || {};
    var ZHAOO = window.ZHAOO || {};
    CONFIG = {
      fancybox: true,
      pjax: false,
      lazyload: {
        enable: true,
        loadingImage: '/images/theme/loading.gif',
      },
      donate: {
        enable: true,
        alipay: '/images/theme/zhifubao.jpg',
        wechat: '/images/theme/weixin.jpg'
      },
      motto: {
        api: '',
        default: '祝你万事胜意'
      },
      galleries: {
        enable: true
      },
      fab: {
        enable: true,
        alwaysShow: false
      },
      carrier: {
        enable: true
      },
      daovoice: {
        enable: true
      }
    }
  </script>

  

  
<meta name="generator" content="Hexo 5.0.0"></head>
<body class="lock-screen">
  <div class="loading"></div>
  


<nav class="navbar">
  <div class="left"></div>
  <div class="center">React核心概念</div>
  <div class="right">
    <i class="iconfont iconmenu j-navbar-menu"></i>
  </div>
</nav>

  <nav class="menu">
  <div class="menu-wrap">
    <div class="menu-close">
      <i class="iconfont iconbaseline-close-px"></i>
    </div>
    <ul class="menu-content">
      
      
      
      
      <li class="menu-item"><a href="/ " class="underline"> 首页</a></li>
      
      
      
      
      <li class="menu-item"><a href="/galleries " class="underline"> 摄影</a></li>
      
      
      
      
      <li class="menu-item"><a href="/archives " class="underline"> 归档</a></li>
      
      
      
      
      <li class="menu-item"><a href="/tags " class="underline"> 标签</a></li>
      
      
      
      
      <li class="menu-item"><a href="/categories " class="underline"> 分类</a></li>
      
      
      
      
      <li class="menu-item"><a href="/about " class="underline"> 关于</a></li>
      
    </ul>
    <div class="menu-copyright"><p>Copyright© 2019-2020 | <a target="_blank" href="https://www.001f3.cn">平常心</a> .AllRightsReserved</p></div>
  </div>
</nav>
  <main id="main">
  <div class="container" id="container">
    <article class="article">
  <section class="head">
  <img   class="lazyload" data-original="/images/theme/post-image.jpg" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  draggable="false">
  <div class="head-mask">
    <h1 class="head-title">React核心概念</h1>
    <div class="head-info">
      <span class="post-info-item"><i class="iconfont iconcalendar"></i>Mar 14, 2021</span
        class="post-info-item">
      
      <span class="post-info-item"><i class="iconfont iconfont-size"></i>16495</span>
    </div>
  </div>
</section>
  <section class="main">
    <section class="content">
      <h1 id="一、最简易的React示例"><a href="#一、最简易的React示例" class="headerlink" title="一、最简易的React示例"></a>一、最简易的React示例</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">ReactDom.render(<br>    &lt;div&gt;Hello, ling!&lt;/div&gt;,<br>    <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;root&#x27;</span>)<br>);<br></code></pre></td></tr></table></figure>
<p>上面这个例子将会在浏览器中展示 “Hello, ling!” 。</p>
<h1 id="二、JSX？"><a href="#二、JSX？" class="headerlink" title="二、JSX？"></a>二、JSX？</h1><h2 id="为什么是JSX？"><a href="#为什么是JSX？" class="headerlink" title="为什么是JSX？"></a>为什么是JSX？</h2><p>React 并不强制使用 JSX，但是大部分人觉得将 JSX 和 UI 放在一起时，能提升视觉效果，并且可以使 React 提示更多的错误和警告。</p>
<h2 id="JSX编译"><a href="#JSX编译" class="headerlink" title="JSX编译"></a>JSX编译</h2><p>Babel 会把 JSX 转译成一个名为 <code>React.createElement()</code> 函数调用，例如下面的代码是等效的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span>  element = (<br>    &lt;div className=<span class="hljs-string">&quot;myEle&quot;</span>&gt;<br>        Hello, ling!<br>    &lt;/div&gt;<br>);<br></code></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> element = React.createElement(<br>    <span class="hljs-string">&#x27;div&#x27;</span>,<br>    &#123;<span class="hljs-attr">className</span>: <span class="hljs-string">&#x27;myEle&#x27;</span>&#125;,<br>    <span class="hljs-string">&#x27;Hello, ling!&#x27;</span><br>);<br></code></pre></td></tr></table></figure>
<p><code>React.createElement</code>实际上会创造以下一个对象（经简化）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> element = &#123;<br>    type: <span class="hljs-string">&#x27;div&#x27;</span>,<br>    props: &#123;<br>        className: <span class="hljs-string">&#x27;myEle&#x27;</span>,<br>        children: <span class="hljs-string">&#x27;Hello, ling!&#x27;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="三、元素如何渲染？"><a href="#三、元素如何渲染？" class="headerlink" title="三、元素如何渲染？"></a>三、元素如何渲染？</h1><p>元素是构成 React 应用的最小砖块，与浏览器的 DOM 元素不同，React 元素是创建开销极小的普通对象。React DOM 会负责更新 DOM 来与 React 元素保持一致。</p>
<h2 id="开始渲染"><a href="#开始渲染" class="headerlink" title="开始渲染"></a>开始渲染</h2><p>假设现在 HTML 上有一个根结点 <code>&lt;div id=&quot;root&quot;&gt;&lt;/div&gt;</code>, 如果你想要在这个根结点中渲染元素，只需要把他们传入 <code>ReactDom.render()</code> 中就可。就像下面这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> element = (<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Hello, ling<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>);<br>ReactDom.render(element, <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;root&#x27;</span>))<br></code></pre></td></tr></table></figure>

<h2 id="如何更新已经渲染的元素？"><a href="#如何更新已经渲染的元素？" class="headerlink" title="如何更新已经渲染的元素？"></a>如何更新已经渲染的元素？</h2><p>React 元素是不可变对象，一旦被创建就无法更改它的子元素或者属性，唯一的更新方法就是重新传入 <code>ReactDom.render()</code>，例如下面这个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Timer</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> element = (<br>        &lt;div&gt;Now, is &#123;<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()&#125;&lt;/div&gt;<br>    );<br>    ReactDom.render(element, <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;root&#x27;</span>))<br>&#125;<br><br><span class="hljs-built_in">setInterval</span>(Timer, <span class="hljs-number">1000</span>);<br></code></pre></td></tr></table></figure>
<p>然而，在实际实践中，大多数的 React 应用只会调用一次 <code>ReactDom.render()</code> 在<strong>第五节</strong>中会解决这个问题。</p>
<h2 id="只更新需要的部分"><a href="#只更新需要的部分" class="headerlink" title="只更新需要的部分"></a>只更新需要的部分</h2><p>利用上面这个例子，使用浏览器检查元素工具可以发现即使每隔一秒都会传入一个全新的元素，但是 React 只会更新它需要更新的部分，例如上面的代码只会更新 <code>&#123;new Date()&#125;</code> 中的内容。</p>
<h1 id="四、组件-amp-amp-Props"><a href="#四、组件-amp-amp-Props" class="headerlink" title="四、组件 &amp;&amp; Props"></a>四、组件 &amp;&amp; Props</h1><h2 id="组件类型"><a href="#组件类型" class="headerlink" title="组件类型"></a>组件类型</h2><p>React 有两种组件，一种是函数组件，另一种是 class 组件。顾名思义，函数组件使用 <code>function</code> 定义的组件，class 组件是用 <code>class</code> 定义的组件。这两者在效果上是等效的，但是在其他特性上有一定差异，详见<strong>第五节</strong>。</p>
<h2 id="渲染组件"><a href="#渲染组件" class="headerlink" title="渲染组件"></a>渲染组件</h2><p>React 元素可以是自定义组件，JSX 会将接收的属性和子组件转换为 <code>props</code> 对象传递给组件。例如下面这段代码将会渲染 “Hello, ling!”：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Welcome</span>(<span class="hljs-params">props</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> (<br>        &lt;div&gt;Hello, &#123;props.name&#125;!&lt;/div&gt;<br>    );<br>&#125;<br><br><span class="hljs-keyword">const</span> element = (<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Welcome</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;ling&quot;</span> /&gt;</span></span>);<br>ReactDom.render(element, <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;root&#x27;</span>))<br></code></pre></td></tr></table></figure>
<p>以上这个例子发生了什么：</p>
<ul>
<li><code>ReactDom.render()</code> 函数传入 element 元素，也就是 Welcome 组件。</li>
<li>React 调用 Welcome 组件并将 <code>&#123;name: &#39;ling&#39;&#125;</code> 作为 props 对象传入。</li>
<li>Welcome 组件将 <code>&lt;div&gt;Hello, ling!&lt;/div&gt;</code> 作为返回值。</li>
<li>React Dom 将 DOM 高效更新为 <code>&lt;div&gt;Hello, ling!&lt;/div&gt;</code>。</li>
</ul>
<p><strong>注意</strong>：React 组件名称必须大写开头，因为 React 会将小写的标签当作原生 DOM 标签，而以大写开头则代表是一个组件，原因将在下一期 <strong>React高级指引</strong> 中详细展开。</p>
<h2 id="组合组件"><a href="#组合组件" class="headerlink" title="组合组件"></a>组合组件</h2><p>引用上面的 <code>&lt;Welcome /&gt;</code> 组件，我们可以多次调用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> (<br>        &lt;div&gt;<br>            &lt;Welcome name=<span class="hljs-string">&quot;ling&quot;</span> /&gt;<br>            &lt;Welcome name=<span class="hljs-string">&quot;yi&quot;</span> /&gt;<br>        &lt;/div&gt;<br>    )<br>&#125;<br><br>ReactDom.render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span></span>, <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;root&#x27;</span>));<br></code></pre></td></tr></table></figure>
<p>通常来说，每个 React 应用的最顶层都是 <code>&lt;App /&gt;</code> 组件。你可能需要引入一些类似 <code>Button</code> 这样的小组件，并将他们自下而上地运用到每一处。为什么说是自下而上的，因为自下而上意味着从最基础的组件开始写，比较适合大部分大一点的项目，而自上而下适合简单的应用。</p>
<h2 id="拆分组件"><a href="#拆分组件" class="headerlink" title="拆分组件"></a>拆分组件</h2><p>拆分组件可以使代码更加易读和维护，在大型应用中，更应该构建可复用组件库。如果代码中有一部分被重复调用或者具有一定复杂性，那么这部分代码是值得被拆分的。例如下面是 React 官方拆分组件的示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Comment</span>(<span class="hljs-params">props</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> (<br>    &lt;div className=<span class="hljs-string">&quot;Comment&quot;</span>&gt;<br>      &lt;div className=<span class="hljs-string">&quot;UserInfo&quot;</span>&gt;<br>        &lt;img className=<span class="hljs-string">&quot;Avatar&quot;</span><br>          src=&#123;props.author.avatarUrl&#125;<br>          alt=&#123;props.author.name&#125;<br>        /&gt;<br>        &lt;div className=<span class="hljs-string">&quot;UserInfo-name&quot;</span>&gt;<br>          &#123;props.author.name&#125;<br>        &lt;/div&gt;<br>      &lt;/div&gt;<br>      &lt;div className=<span class="hljs-string">&quot;Comment-text&quot;</span>&gt;<br>        &#123;props.text&#125;<br>      &lt;/div&gt;<br>      &lt;div className=<span class="hljs-string">&quot;Comment-date&quot;</span>&gt;<br>        &#123;formatDate(props.date)&#125;<br>      &lt;/div&gt;<br>    &lt;/div&gt;<br>  );<br>&#125;<br></code></pre></td></tr></table></figure>
<p>首先提取 <code>Avatar</code> 组件, 这里建议将 author 改为 user, 因为 <code>Avatar</code> 并不知道 <code>Comment</code> 是用来干嘛的，官方建议从组件自身的角度命名属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Avatar</span>(<span class="hljs-params">props</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> (<br>        &lt;img className=<span class="hljs-string">&quot;Avatar&quot;</span><br>          src=&#123;props.user.avatarUrl&#125;<br>          alt=&#123;props.user.name&#125;<br>        /&gt;<br>    )<br>&#125;<br></code></pre></td></tr></table></figure>
<p>再提取 <code>UserInfo</code> 组件, 并引入 <code>Avatar</code> 组件</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">UserInfo</span>(<span class="hljs-params">props</span>) </span>&#123;<br>    &lt;div className=<span class="hljs-string">&quot;userInfo&quot;</span>&gt;<br>        &lt;Avatar user=&#123;props.user&#125;/&gt;<br>        &lt;div className=<span class="hljs-string">&quot;UserInfo-name&quot;</span>&gt;<br>            &#123;props.user.name&#125;<br>        &lt;/div&gt;<br>    &lt;/div&gt;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>最终形成的 <code>Comment</code> 组件如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Comment</span>(<span class="hljs-params">props</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> (<br>    &lt;div className=<span class="hljs-string">&quot;Comment&quot;</span>&gt;<br>      &lt;UserInfo user=&#123;props.author&#125; /&gt;<br>      &lt;div className=<span class="hljs-string">&quot;Comment-text&quot;</span>&gt;<br>        &#123;props.text&#125;<br>      &lt;/div&gt;<br>      &lt;div className=<span class="hljs-string">&quot;Comment-date&quot;</span>&gt;<br>        &#123;formatDate(props.date)&#125;<br>      &lt;/div&gt;<br>    &lt;/div&gt;<br>  );<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="props-是只读的"><a href="#props-是只读的" class="headerlink" title="props 是只读的"></a>props 是只读的</h2><p>React 有一个严格的规则：<strong>所有 React 组件都必须像纯函数一样保护它们的 props 不被更改</strong>，什么是纯函数？对比下面两个例子就知道了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a, b</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> a + b<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这是一个纯函数，因为入参 a 和 b 没有发生改变。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">total, a</span>) </span>&#123;<br>    total = total+a<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这不是一个纯函数，因为入参 total 发生了改变。</p>
<h1 id="五、-State-amp-amp-生命周期"><a href="#五、-State-amp-amp-生命周期" class="headerlink" title="五、 State &amp;&amp; 生命周期"></a>五、 State &amp;&amp; 生命周期</h1><p>引用上面<strong>第三节</strong>中一个定时器 <code>Timer</code> 组件，在该组件中需要不断触发计时器来达到更新UI的效果，理想情况下，我们应该只编码一次来达到这个效果，state 就是干这个的，state 和 props 类型，只不过 state 是私有的，并且完全受控于当前组件。</p>
<h2 id="利用生命周期和state改造定时器-Timer"><a href="#利用生命周期和state改造定时器-Timer" class="headerlink" title="利用生命周期和state改造定时器 Timer"></a>利用生命周期和state改造定时器 <code>Timer</code></h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Clock</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>  <span class="hljs-keyword">constructor</span>(props) &#123;<br>    <span class="hljs-built_in">super</span>(props);<br>    <span class="hljs-built_in">this</span>.state = &#123;<span class="hljs-attr">date</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()&#125;;<br>  &#125;<br><br>  componentDidMount() &#123;<br>    <span class="hljs-built_in">this</span>.timerID = <span class="hljs-built_in">setInterval</span>(<br>      () =&gt; <span class="hljs-built_in">this</span>.tick(),<br>      <span class="hljs-number">1000</span><br>    );<br>  &#125;<br><br>  componentWillUnmount() &#123;<br>    <span class="hljs-built_in">clearInterval</span>(<span class="hljs-built_in">this</span>.timerID);<br>  &#125;<br><br>  tick() &#123;<br>    <span class="hljs-built_in">this</span>.setState(&#123;<br>      date: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()<br>    &#125;);<br>  &#125;<br><br>  render() &#123;<br>    <span class="hljs-keyword">return</span> (<br>      &lt;div&gt;<br>        &lt;h1&gt;Hello, world!&lt;/h1&gt;<br>        &lt;h2&gt;It is &#123;<span class="hljs-built_in">this</span>.state.date.toLocaleTimeString()&#125;.&lt;/h2&gt;<br>      &lt;/div&gt;<br>    );<br>  &#125;<br>&#125;<br><br>ReactDOM.render(<br>  &lt;Clock /&gt;,<br>  <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;root&#x27;</span>)<br>);<br></code></pre></td></tr></table></figure>
<p>该代码发生了什么？</p>
<ol>
<li>当执行到 <code>ReactDom.render()</code> 时，<code>Clock</code> 组件被传入，构造函数 construct 被触发，state 初始化。</li>
<li><code>Clock</code> 组件调用 <code>render()</code> 方法，React 更新 Dom。</li>
<li>当 <code>Clock</code> 输出的内容被插入 Dom 之后，会触发 <code>ComponentDidMount()</code> 生命周期，计时器被建立，每秒都会调用 <code>tick()</code> 方法。</li>
<li><code>tick()</code> 方法被调用，state 发生改变，<code>render()</code> 重新触发，React 重新更新 Dom。</li>
<li>当 <code>Clock</code> 组件从 Dom 中移除时会触发 <code>componentWillUnmount()</code> 生命周期，计时器被移除。<h2 id="正确使用State"><a href="#正确使用State" class="headerlink" title="正确使用State"></a>正确使用State</h2><h3 id="不要直接修改State"><a href="#不要直接修改State" class="headerlink" title="不要直接修改State"></a>不要直接修改State</h3>直接修改的 state 不会触发 <code>render()</code>，视图不会更新。例如下面：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// wrong</span><br><span class="hljs-built_in">this</span>.state.name = <span class="hljs-string">&#x27;lisi&#x27;</span>;<br></code></pre></td></tr></table></figure>
应该调用 <code>setState()</code> 方法。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// correct</span><br><span class="hljs-built_in">this</span>.setState(&#123;<br>    name: <span class="hljs-string">&#x27;lisi&#x27;</span><br>&#125;);<br></code></pre></td></tr></table></figure>
构造函数是唯一可以给 state 赋值的地方。<h3 id="State的更新是异步的"><a href="#State的更新是异步的" class="headerlink" title="State的更新是异步的"></a>State的更新是异步的</h3>出于性能考虑，React 可能会把多个 <code>setState()</code> 合并成一个调用</li>
</ol>
<p>所以 <code>this.state</code> 和 <code>this.props</code> 是异步更新的，所以不要依赖他们的值来更新下一个状态。如果要解决这个问题，请使用函数。例如下面是一个错误示例和正确示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// wrong</span><br><span class="hljs-built_in">this</span>.setState(&#123;<br>    user: <span class="hljs-built_in">this</span>.state.id + <span class="hljs-built_in">this</span>.props.name,<br>&#125;);<br></code></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// correct</span><br><span class="hljs-built_in">this</span>.setState(<span class="hljs-function">(<span class="hljs-params">state, props</span>)=&gt;</span> (&#123;<br>    user: state.id + props.name,<br>&#125;));<br></code></pre></td></tr></table></figure>
<h3 id="State的更新会被合并"><a href="#State的更新会被合并" class="headerlink" title="State的更新会被合并"></a>State的更新会被合并</h3><p>例如下面有两个 state :</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">construct(props) &#123;<br>    <span class="hljs-built_in">super</span>(props)<br>    <span class="hljs-built_in">this</span>.state = &#123;<br>        name: <span class="hljs-string">&#x27;lisi&#x27;</span>,<br>        age: <span class="hljs-number">20</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>可以分别更新这两个状态</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">this</span>.setState(&#123;name&#125;);<br><span class="hljs-built_in">this</span>.setState(&#123;age&#125;);<br></code></pre></td></tr></table></figure>
<p>这是一种浅合并，更新 name 时会完整保留 age, 完全替换 name。更新 age 时同理。</p>
<h2 id="数据向下流动"><a href="#数据向下流动" class="headerlink" title="数据向下流动"></a>数据向下流动</h2><p>不管是父组件还是子组件，都无法知道某个组件是有状态组件还是无状态组件，因为 state 是私有的，当父组件向子组件传值时，该子组件并不知道这个 props 对象是来自父组件的 state 还是 props，这种现象称为数据的向下流动，也叫单向数据流。任何从某个组件中衍生出来的 state 只能影响“低于”它们的组件。</p>
<h1 id="六、事件处理"><a href="#六、事件处理" class="headerlink" title="六、事件处理"></a>六、事件处理</h1><h2 id="与传统-DOM-语法不同"><a href="#与传统-DOM-语法不同" class="headerlink" title="与传统 DOM 语法不同"></a>与传统 DOM 语法不同</h2><ol>
<li>React 事件命名采用驼峰式，而不是纯小写</li>
<li>React 事件绑定采用传入函数，而不是一个字符串，例如：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 传统 HTML</span><br>&lt;button onClick=<span class="hljs-string">&quot;clickMe()&quot;</span>&gt;<br>    click me<br>&lt;/button&gt;<br></code></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// React</span><br>&lt;button onClick=&#123;clickMe&#125;&gt;<br>    click me<br>&lt;/button&gt;<br></code></pre></td></tr></table></figure></li>
<li>传统 HTML 可以通过返回 false 来阻止默认行为，在 React 必须显式使用<code>preventDefault</code> 例如：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 传统 HTML</span><br>&lt;a href=<span class="hljs-string">&quot;#&quot;</span> onClick=<span class="hljs-string">&quot;return false&quot;</span>&gt;click me&lt;/a&gt;<br></code></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// React</span><br><span class="hljs-keyword">const</span> clickMe = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>    e.preventDefault();<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;i am clicked&#x27;</span>);<br>&#125;<br>&lt;a href=<span class="hljs-string">&quot;#&quot;</span> onClick=&#123;clickMe&#125;&gt;click me&lt;/a&gt;<br></code></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="class-中的-this"><a href="#class-中的-this" class="headerlink" title="class 中的 this"></a>class 中的 this</h2><p>class 中的方法默认不会绑定this,假如你执行下面一段代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThis</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">component</span> </span>&#123;<br>    construct(props) &#123;<br>        <span class="hljs-built_in">super</span>(props)<br>        <span class="hljs-built_in">this</span>.state = &#123;<br>            name: <span class="hljs-string">&#x27;zhangsan&#x27;</span>,<br>            age: <span class="hljs-number">20</span>,<br>        &#125;<br>    &#125;<br>    handleClick() &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name) <span class="hljs-comment">//undefined</span><br>    &#125;<br>    render() &#123;<br>        <span class="hljs-keyword">return</span> (<br>            &lt;button onClick=&#123;<span class="hljs-built_in">this</span>.handleClick&#125;&gt;click test&lt;/button&gt;<br>        )<br>    &#125;<br>&#125;<br><br>ReactDom.render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">MyThis</span> /&gt;</span></span>, <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;root&#x27;</span>))<br></code></pre></td></tr></table></figure>
<p>上面代码当点击按钮的时候会在控制台打印 undefined，要想解决这类问题，有三种方法。</p>
<ol>
<li>在构造函数中绑定 this, 例如：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript">construct(props) &#123;<br>    <span class="hljs-built_in">super</span>(props)<br>    <span class="hljs-built_in">this</span>.state = &#123;<br>        name: <span class="hljs-string">&#x27;zhangsan&#x27;</span>,<br>        age: <span class="hljs-number">20</span>,<br>    &#125;<br>    <span class="hljs-built_in">this</span>.handleClick = <span class="hljs-built_in">this</span>.handleClick.bind(<span class="hljs-built_in">this</span>)<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>在定义函数时使用箭头函数, 例如：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">handleClick = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name) <span class="hljs-comment">// zhangsan</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>在绑定事件时采用箭头函数, 例如：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;button onClick=&#123;<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">this</span>.handleClick()&#125;&gt;click test&lt;/button&gt;<br></code></pre></td></tr></table></figure>
以上三种方法都是可以改变函数中的this指向，第一种基本没有局限性，第二种需要你使用实验性的 public class fields 语法，第三种在大多数情况下没什么问题，但如果该回调函数作为 prop 传入子组件时，这些组件可能会进行额外的重新渲染， <strong>为什么？</strong> React 更新元素时只更新需要的部分，当 diff 算法触发时会触发浅比较，如果在 render 中创建函数，会在每次渲染的时候都创建一个新的函数，这时浅比较会触发 false，即使你没有发生任何变化，子组件也会重新渲染。</li>
</ol>
<h2 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h2><p>传递参数没什么好说的，来说说事件对象 e 吧。当你在事件绑定时采用箭头函数的形式，那么该显式地传递e, 当你用其他两种方法时，e 更多的会被当作后一个参数隐式传入，例如下面两种方法式等价的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;button onClick=&#123;<span class="hljs-function">(<span class="hljs-params">id, e</span>) =&gt;</span> <span class="hljs-built_in">this</span>.delete(id, e)&#125;&gt;click&lt;/button&gt;<br>&lt;button onClick=&#123;<span class="hljs-built_in">this</span>.delete.bind(<span class="hljs-built_in">this</span>, id)&#125;&gt;click&lt;/button&gt;<br></code></pre></td></tr></table></figure>
<h1 id="七、条件渲染"><a href="#七、条件渲染" class="headerlink" title="七、条件渲染"></a>七、条件渲染</h1><h2 id="运算符-if"><a href="#运算符-if" class="headerlink" title="运算符 if"></a>运算符 if</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Condition</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">component</span> </span>&#123;<br>    state = &#123;<br>        isAdmin: <span class="hljs-literal">false</span><br>    &#125;<br>    <br>    render() &#123;<br>        <span class="hljs-keyword">const</span> &#123; isAdmin &#125; = <span class="hljs-built_in">this</span>.state<br>        <span class="hljs-keyword">let</span> button;<br>        <span class="hljs-keyword">if</span> (isAdmin) &#123;<br>            button = (<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            button = (<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>)<br>        &#125;<br>        <span class="hljs-keyword">return</span> (<br>            &lt;div&gt;<br>                &#123;button&#125;<br>            &lt;/div&gt;<br>        )<br>    &#125;<br>&#125;<br>ReactDom.render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Condition</span> /&gt;</span></span>, <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;root&#x27;</span>))<br></code></pre></td></tr></table></figure>

<h2 id="运算符-amp-amp"><a href="#运算符-amp-amp" class="headerlink" title="运算符 &amp;&amp;"></a>运算符 &amp;&amp;</h2><p>利用上面的例子，我们的 <code>render()</code> 可以这么写</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript">render() &#123;<br>    <span class="hljs-keyword">const</span> &#123; isAdmin &#125; = <span class="hljs-built_in">this</span>.state<br>    <span class="hljs-keyword">return</span> (<br>        &#123;<br>            isAdmin &amp;&amp; <br>            button = (<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>)<br>        &#125;<br>        &#123;<br>            !isAdmin &amp;&amp;<br>            button = (<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>)<br>        &#125;<br>    )<br>&#125;<br></code></pre></td></tr></table></figure>
<p>之所以能这么写是因为假如 &amp;&amp; 左侧的元素是 true，那么会返回右侧的元素，假如左侧元素是 false，那么会跳过右侧的元素，但是会返回 false 表达式，所以这里有一个坑。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript">render() &#123;<br>    <span class="hljs-keyword">const</span> count = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">return</span> (<br>        &lt;div&gt;count &amp;&amp; <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>count: &#123;count&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>&lt;/div&gt;<br>    )<br>&#125;<br></code></pre></td></tr></table></figure>
<p>上面的表达式会返回 <code>&lt;div&gt;0&lt;/div&gt;</code></p>
<h2 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符"></a>三目运算符</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript">render() &#123;<br>    <span class="hljs-keyword">const</span> &#123; isAdmin &#125; = <span class="hljs-built_in">this</span>.state<br>    <span class="hljs-keyword">return</span> (<br>        &#123;<br>            isAdmin? <br>            &lt;button&gt;<span class="hljs-literal">true</span>&lt;/button&gt;<br>            :<br>            &lt;button&gt;<span class="hljs-literal">false</span>&lt;/button&gt;<br>        &#125;<br>    )<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="阻止组件渲染"><a href="#阻止组件渲染" class="headerlink" title="阻止组件渲染"></a>阻止组件渲染</h2><p>例如现在有一个组件 <code>children</code>, 它被两个父组件调用，其中一个父组件中需要展示，另一个父组件中需要隐藏，我们可以通过返回 null的形式来隐藏该组件，而且这并不影响父组件的生命周期</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Children</span>(<span class="hljs-params">props</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span>(!props.isAdmin) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> (<br>        &lt;button&gt;<span class="hljs-literal">true</span>&lt;/button&gt;<br>    );<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="八、列表-amp-amp-key"><a href="#八、列表-amp-amp-key" class="headerlink" title="八、列表 &amp;&amp; key"></a>八、列表 &amp;&amp; key</h1><h2 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h2><p>我们可以通过 <code>map()</code> 方法来遍历数组并将数组中每个元素都渲染成标签，例如下面:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><span class="hljs-keyword">const</span> listItem = arr.map(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> (<br>    &lt;li&gt;&#123;item&#125;&lt;/li&gt;<br>));<br><br>ReactDom.render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>&#123;listItem&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span>, <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;root&#x27;</span>));<br></code></pre></td></tr></table></figure>
<p>这会产生一个 1 到 5 的列表，但是在控制台会发现一个警告 <code>a key should be provided for list items</code> ，这是因为你没有指定 key 的值。</p>
<h2 id="key"><a href="#key" class="headerlink" title="key"></a>key</h2><ol>
<li>key 可以帮助 React 高效识别哪些元素发生了改变，哪些元素没有发生改变。所以，key最好是一个独一无二的值，比如 id 。万不得已时，可以使用 index ，但是并不推荐，因为当你的数组中某些元素的顺序发生变化时， index 并没有发生变化，这不会导致重新渲染。</li>
<li>key 设定的位置也是比较讲究的，只有放在就近数组的上下文才会生效，一般都是在 <code>map()</code> 方法中指定。</li>
<li>当 key 绑定在一个组件上时，子组件 props 对象中并没有 key 属性，所以最好不要用 key 来传递一些状态。</li>
<li>key 只是在兄弟节点之间唯一，并不是全局唯一，所以不同数组可以使用相同的 key。</li>
</ol>
<h1 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h1><h2 id="非受控组件"><a href="#非受控组件" class="headerlink" title="非受控组件"></a>非受控组件</h2><p>与传统的 HTML 标签不同，<code>form</code> 表单会自己维护一个状态。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;form&gt;<br>  &lt;label&gt;<br>    名字:<br>    &lt;input type=<span class="hljs-string">&quot;text&quot;</span> name=<span class="hljs-string">&quot;name&quot;</span> /&gt;<br>  &lt;/label&gt;<br>  &lt;input type=<span class="hljs-string">&quot;submit&quot;</span> value=<span class="hljs-string">&quot;提交&quot;</span> /&gt;<br>&lt;/form&gt;<br></code></pre></td></tr></table></figure>
<p>例如这段代码会触发表单默认事件，即提交后跳转到新的页面，如果你需要做一些特殊操作，请使用<strong>受控组件</strong>。</p>
<h2 id="受控组件"><a href="#受控组件" class="headerlink" title="受控组件"></a>受控组件</h2><p>顾名思义，受控组件是“受控”的，就是让 React 内部的 state 来接管 form 表单，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyForm</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">component</span> </span>&#123;<br>    state = &#123;<br>        myName: <span class="hljs-string">&#x27;initValue&#x27;</span>,<br>        myContent: <span class="hljs-string">&#x27;initContent&#x27;</span>,<br>        myCheck: <span class="hljs-literal">false</span>,<br>    &#125;<br><br>    inputChange = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">const</span> target = e.target<br>        <span class="hljs-keyword">const</span> value = target.type === <span class="hljs-string">&#x27;checkbox&#x27;</span>? target.checked : target.value<br>        <span class="hljs-keyword">const</span> name = target.name<br>        <span class="hljs-built_in">this</span>.setState(&#123;<br>            [name]: value,<br>        &#125;)<br>    &#125;<br><br>    render() &#123;<br>        <span class="hljs-keyword">const</span> &#123; myName, myContent, myCheck &#125; = <span class="hljs-built_in">this</span>.state<br>        <span class="hljs-keyword">return</span> (<br>            &lt;form&gt;<br>              &lt;label&gt;<br>                名字:<br>                &lt;input type=<span class="hljs-string">&quot;text&quot;</span> name=<span class="hljs-string">&quot;myName&quot;</span> value=&#123;myName&#125; onChange=&#123;<span class="hljs-built_in">this</span>.inputChange&#125;/&gt;<br>              &lt;/label&gt;<br>              &lt;input type=<span class="hljs-string">&quot;checkbox&quot;</span> name=<span class="hljs-string">&quot;myCheck&quot;</span> checked=&#123;myCheck&#125; onChange=&#123;<span class="hljs-built_in">this</span>.inputChange&#125;/&gt;<br>              &lt;input type=<span class="hljs-string">&quot;text&quot;</span>  name=<span class="hljs-string">&quot;myContent&quot;</span> value=&#123;myContent&#125; onChange=&#123;<span class="hljs-built_in">this</span>.inputChange&#125;/&gt;<br>            &lt;/form&gt;<br>        )<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>上面代码中有三个关键点：</p>
<ol>
<li>用 <code>value</code> 或者 <code>checked</code> 接管表单标签的状态， 用<code>onChange</code>事件触发state 改变从而重新渲染页面。</li>
<li>所有状态都来自组件内部的状态，state 成为唯一数据源，所以是受控组件。</li>
<li>给不同的标签绑定name，使用一个函数就可以管理多种标签。这里用到了 ES6 的计算属性名称语法。<h2 id="受控组件输入空值"><a href="#受控组件输入空值" class="headerlink" title="受控组件输入空值"></a>受控组件输入空值</h2>在<strong>受控组件</strong>上使用 value 会阻止用户输入，如果此时用户还能输入，可能该 value 值为 null 或 undefined,例如下面：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">ReactDOM.render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;hi&quot;</span> /&gt;</span></span>, mountNode);<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  ReactDOM.render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;null&#125;</span> /&gt;</span></span>, mountNode);<br>&#125;, <span class="hljs-number">1000</span>);<br></code></pre></td></tr></table></figure>
一开始用户是无法输入的，隔一段时间后可以进行输入。</li>
</ol>
<h1 id="九、状态提升"><a href="#九、状态提升" class="headerlink" title="九、状态提升"></a>九、状态提升</h1><p>状态提升的具体操作方法这里不做赘述，简单的说就是将子组件的 state 和操作 state 的方法提取到父组件中，然后利用自上而下的数据流，子组件可以从 props 对象中接收状态。</p>
<h2 id="何时需要状态提升"><a href="#何时需要状态提升" class="headerlink" title="何时需要状态提升"></a>何时需要状态提升</h2><p>当兄弟组件之间需要利用对方的状态，这时最好的办法就是将这个 state 提取到他们的公共父组件中，然后利用“自上而下数据流”注入子组件中，也就是单向数据流。</p>
<h2 id="为什么不用双向绑定，"><a href="#为什么不用双向绑定，" class="headerlink" title="为什么不用双向绑定，"></a>为什么不用双向绑定，</h2><p>React 的单向数据流会造成代码量增多，但是也会带来一些好处，因为数据流是单向的，在遇到问题解决 bug 的时候，bug 的排查范围被大大减少了。</p>
<h2 id="弊端"><a href="#弊端" class="headerlink" title="弊端"></a>弊端</h2><p>除了代码量增多的缺点外，当你的应用不断变大时，你会发现如果始终采用自上而下的数据流，状态管理会被变得非常复杂并且不易维护，但还好，mobx，redux的出现缓解了这种尴尬，他们会把需要共享的状态存放在 store 中，然后分别注入到需要的组件。</p>
<h1 id="十、组合-VS-继承"><a href="#十、组合-VS-继承" class="headerlink" title="十、组合 VS 继承"></a>十、组合 VS 继承</h1><p>React 拥有非常强大的组合模式，推荐使用组合而非继承。</p>
<h2 id="包含关系"><a href="#包含关系" class="headerlink" title="包含关系"></a>包含关系</h2><p>有些组件并不能提前知道子组件的具体内容。我们可以利用 <code>children</code> prop来将子组件的内容渲染到父组件中</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">MyBox</span>(<span class="hljs-params">props</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> (<br>        &lt;div className=&#123;<span class="hljs-string">&#x27;myBox&#x27;</span> + props.color&#125;&gt;<br>            &#123;props.children&#125;<br>        &lt;/div&gt;<br>    )<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">WelcomeDialog</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span>(<br>        &lt;MyBox color=<span class="hljs-string">&quot;red&quot;</span>&gt;<br>            &lt;div&gt;<br>                &lt;h1&gt;Welcome !&lt;/h1&gt;<br>                &lt;p&gt;i am welcome dialog&lt;/p&gt;<br>            &lt;/div&gt;<br>        &lt;/MyBox&gt;<br>    )<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>&lt;MyBox&gt;&lt;/MyBox&gt;</code> 标签中内容将会作为 <code>props.children</code> 传递给自身组件。但是有时候 <code>children</code> 并不管用，例如下面：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">MyBox</span>(<span class="hljs-params">props</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> (<br>        &lt;div className=<span class="hljs-string">&quot;myBox&quot;</span>&gt;<br>            &lt;div className=<span class="hljs-string">&quot;header&quot;</span>&gt;<br>                &#123;props.top&#125;<br>            &lt;/div&gt;<br>            &#123;props.children&#125;<br>            &lt;div className=<span class="hljs-string">&quot;footer&quot;</span>&gt;<br>                &#123;props.bottom&#125;<br>            &lt;/div&gt;<br>        &lt;/div&gt;<br>    )<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">WelcomeDialog</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span>(<br>        &lt;MyBox top=&#123;<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Top</span> /&gt;</span></span>&#125; bottom=&#123;<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Bottom</span> /&gt;</span></span>&#125;&gt;<br>            &lt;div&gt;<br>                &lt;h1&gt;Welcome !&lt;/h1&gt;<br>                &lt;p&gt;i am welcome dialog&lt;/p&gt;<br>            &lt;/div&gt;<br>        &lt;/MyBox&gt;<br>    )<br>&#125;<br></code></pre></td></tr></table></figure>
<p>因为像 <code>&lt;Top /&gt;</code> 这样的组件本身就是 React 元素，而 React 元素本质就是一个对象，所以可以把他们当作 props 用作传递。</p>
<h2 id="特例关系"><a href="#特例关系" class="headerlink" title="特例关系"></a>特例关系</h2><p>比如现在有一个 <code>Dialog</code> 组件, 而 <code>WelcomeDialog</code> 只是它一种特殊的表现形式。这也可以用组合实现，例如下面：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Dialog</span>(<span class="hljs-params">props</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> (<br>        &lt;div&gt;<br>            &lt;h1&gt;&#123;props.title&#125;&lt;/h1&gt;<br>            &lt;p&gt;&#123;props.message&#125;&lt;/p&gt;<br>        &lt;/div&gt;<br>    )<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">WelcomeDialog</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> (<br>        &lt;Dialog <br>            title=<span class="hljs-string">&quot;Welcome !&quot;</span><br>            message=<span class="hljs-string">&quot;i am welcome dialog&quot;</span> /&gt;<br>    )<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="继承去哪了"><a href="#继承去哪了" class="headerlink" title="继承去哪了"></a>继承去哪了</h2><p>目前来看，组合能满足所有场景需求，并不需要继承。当你要复用非 UI 的功能时，也可以创建一个单独 js 模块并用 export 暴露，并在需要的组件中用 import 引入。</p>
<h1 id="十一、React-哲学"><a href="#十一、React-哲学" class="headerlink" title="十一、React 哲学"></a>十一、React 哲学</h1><p>这一块我认为更多需要实践吧，可以形成自己的构建思维，React 官方建议的思路如下：</p>
<ol>
<li>将设计好的 UI 划分为组件层级</li>
<li>用 React 创建一个静态版本</li>
<li>确定 UI state 的最小（且完整）表示</li>
<li>确定 state 放置的位置</li>
<li>添加反向数据流</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>到此，React 核心概念已经结束了。回顾一些重要的概念：</p>
<ol>
<li>最好使用JSX</li>
<li>元素渲染只更新需要更新的部分</li>
<li>组件根据复杂性和复用性进行拆分组合，props是只读的</li>
<li>state 是组件私有的，组件具有生命周期函数</li>
<li>事件处理需要绑定this,或者使用箭头函数</li>
<li>三种条件渲染的方式：if运算符，&amp;&amp;运算符，三目运算符</li>
<li>使用 <code>map()</code> 需要绑定 key</li>
<li>受控组件利用组件自身的状态，非受控组件利用标签自带的状态</li>
<li>状态提升的方法和时机</li>
<li>拥抱组合抛弃继承 </li>
<li>五步走构建 React 应用</li>
</ol>

    </section>
    <section class="extra">
      
        <ul class="copyright">
  
  <li><strong>版权声明：</strong>本博客所有文章均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh"
      rel="external nofollow" target="_blank"> BY-NC-SA </a>许可协议，转载请注明出处！</li>
  
</ul>
      
      
        <section class="donate">
  <div class="qrcode">
    <img   class="lazyload" data-original="/images/theme/zhifubao.jpg" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" >
  </div>
  <div class="icon">
    <a href="javascript:;" id="alipay"><i class="iconfont iconalipay"></i></a>
    <a href="javascript:;" id="wechat"><i class="iconfont iconwechat-fill"></i></a>
  </div>
</section>
      
      
      
<nav class="nav">
  
    <a href="/2021/03/17/ReactHooks/"><i class="iconfont iconleft"></i>React Hook</a>
  
  
    <a href="/2020/10/21/Vue/">【学习笔记】Vue篇<i class="iconfont iconright"></i></a>
  
</nav>

    </section>
    
      <section class="comments">
        
          <div class="btn" id="comments-btn">查看评论</div>
        
        
      </section>
    
  </section>
</article>
  </div>
</main>
  <footer class="footer">
  <div class="footer-social">
    
    
    
    
    
    <a href="tencent://message/?Menu=yes&uin=969122484 " target="_blank" onMouseOver="this.style.color= '#12B7F5'"
      onMouseOut="this.style.color='#33333D'">
      <i class="iconfont footer-social-item  iconQQ "></i>
    </a>
    
    
    
    
    
    <a href="javascript:; " target="_blank" onMouseOver="this.style.color= '#09BB07'"
      onMouseOut="this.style.color='#33333D'">
      <i class="iconfont footer-social-item  iconwechat-fill "></i>
    </a>
    
    
    
    
    
    <a href="https://github.com/ImDaret " target="_blank" onMouseOver="this.style.color= '#24292E'"
      onMouseOut="this.style.color='#33333D'">
      <i class="iconfont footer-social-item  icongithub-fill "></i>
    </a>
    
    
    
    
    
    <a href="ling_jintao@163.com " target="_blank" onMouseOver="this.style.color='#FFBE5B'"
      onMouseOut="this.style.color='#33333D'">
      <i class="iconfont footer-social-item  iconmail"></i>
    </a>
    
  </div>
  <div class="footer-copyright"><p>Copyright© 2019-2020 | <a target="_blank" href="https://www.001f3.cn">平常心</a> .AllRightsReserved</p></div>
</footer>
  
      <div class="fab fab-plus">
    <i class="iconfont iconplus"></i>
  </div>
  
  <div class="fab fab-daovoice">
    <i class="iconfont iconcomment"></i>
  </div>
  
  <div class="fab fab-up">
    <i class="iconfont iconcaret-up"></i>
  </div>
  
</body>


<script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>






<script src="https://cdn.bootcdn.net/ajax/libs/jquery.lazyload/1.9.1/jquery.lazyload.min.js"></script>






<script src="https://cdn.bootcdn.net/ajax/libs/justifiedGallery/3.7.0/js/jquery.justifiedGallery.min.js"></script>






<script src="https://cdn.bootcss.com/fancybox/3.5.7/jquery.fancybox.min.js"></script>






<script src="/js/utils.js"></script>
<script src="/js/modules.js"></script>
<script src="/js/zui.js"></script>
<script src="/js/script.js"></script>





<script>
  (function (i, s, o, g, r, a, m) {
    i["DaoVoiceObject"] = r;
    i[r] = i[r] || function () {
      (i[r].q = i[r].q || []).push(arguments)
    }, i[r].l = 1 * new Date();
    a = s.createElement(o), m = s.getElementsByTagName(o)[0];
    a.async = 1;
    a.src = g;
    a.charset = "utf-8";
    m.parentNode.insertBefore(a, m)
  })(window, document, "script", ('https:' == document.location.protocol ? 'https:' : 'http:') +
    "//widget.daovoice.io/widget/0f81ff2f.js", "daovoice")
  daovoice('init', {
    app_id: "abcdefg"
  }, {
    launcher: {
      disableLauncherIcon: true,
    },
  });
  daovoice('update');
</script>



<script>
  (function () {
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
      bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    } else {
      bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
  })();
</script>


<script>
  var _hmt = _hmt || [];
  (function () {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?4c204d8bc027a0455b5fc642ac334ca8";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
  })();
</script>










</html>